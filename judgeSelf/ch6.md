

### 进程的建立
1. 创建一个独立的虚拟地址空间，建立虚拟地址空间与内存的映射（可推迟至缺页时）
2. 读取可执行文件头，并且建立虚拟地址空间与可执行文件的映射
3. 将cpu的指令寄存器设置为可执行文件的入口地址，启动运行


### 页错误
1. CPU将控制权交给系统
2. 异常处理程序根据映射关系，将可执行程序装在进内存并建立映射关系，将控制权返回给进程

### ELF文件链接视图与执行视图
1. 以段为单位映射至虚拟地址空间，每个段单独映射，造成空间浪费
2. 根据段的权限进行划分：
    - 代码段等为可读可执行
    - 数据段等为可读可写
    - 只读段等为只读
3. 权限相同的段先合并再映射
4. 从Section角度看是链接视图
5. 从Segment角度看是装载视图
6. ELF格式的可执行文件和共享库文件中有一个程序头表，记录Segment信息，ELF目标文件不需要被装载，没有PHT

### Linux内核装载ELF
1. 用户层面，bash调用fork系统调用创建一个新进程，新进程调用execve()系统调用还在线指定的ELF文件
   原先的bash进程继续返回等待刚才启动的新进程结束，然后继续等待用户输入命令



## 动态链接
### 链接时重定位
1. 运用于静态链接
2. 读取所有目标文件、库文件，确定各个符号的位置
3. 对引用符号进行重定位操作

### 装载时重定位：解决有绝对地址引用的办法之一
1. 运用于动态链接，-shared
2. 装载时将所有动态库加载进内存，确定各个符号的位置
3. 对引用符号进行重定位操作

### 地址无关代码 -fPIC
1. 将共享指令划分为可修改部分和不可修改部分，可修改部分与数据部分放在一起，不同进程有各自的副本。不可修改部分所有进程共享
2. 

### 动态链接与静态链接比较
1. 动态链接比静态链接慢的原因在于
    - 动态链接对于全局和静态的数据访问都要进行复杂的GOT定位，然后简介寻址
    - 动态链接对于模块间的调用也要先定位GOT，然后再进行间接跳转
    - 动态链接在每次开始执行时进行链接工作

