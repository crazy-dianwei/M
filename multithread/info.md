* 多进程同步方式：管道、具名管道、共享内存、信号量、消息队列、socket


* NPTL(native POSIX Thread Library)
  * glibc的一部分
  * 创建线程和结束线程
  * 读取和设置线程属性
  * POSIX线程同步方式：POSIX信号量、互斥锁和条件变量

* 内核线程
  * 内核空间运行，内核调度
  * 内核线程获得CPU的使用权时，加载并允许一个用户线程
  * 内核线程相当于用户线程运行的容器，数量比例为M：N，比值固定
  * 按照M：N的取值，线程的实现方式可分为三种模式：
    * 完全在用户空间实现，M=1。内核不知道用户线程的存在，由线程库管理，优先级、时间片等。利用longjmp来切换线程的执行
    * 完全由内核调度，M=N。完全由内核调度，利用多核，切换线程等同于切换进程
    * 双层调度，M < N

* 用户线程
  * 用户空间运行，线程库调度 

* NPTL采用1：1方式实现，即完全由内核调度
* LinuxThreads：利用clone系统调用实现，子进程和调用进程共享相同的虚拟地址空间、fds和信号处理函数
* NPTL提供真正的内核线程
  * 内核线程不再是一个进程
  * 摒弃了管理线程，终止线程、回收线程堆栈等工作都可以由内核来完成
  * 不存在管理线程，一个进程的线程可以运行在不同的CPU上
  * 线程同步由内核来完成

* API
  * pthread_create
  * pthread_exit
  * pthread_detach
  * pthread_join(pthread_t, void**)，回收其他线程
    * 该函数会一直阻塞，直到被回收的线程结束为止。成功时返回0，失败则返回错误码
      * EDEADLK：可能引起死锁，相互join，或者对自身调用join
      * EINVAL：目标线程不可回收
      * ESRCH：目标线程不存在
  * pthread_cancel(pthread_t),取消线程，即异常终止一个线程

* JOINABLE和DETACH
  * join表示该线程可回收
  * detach表示脱离于进程中其他线程的同步，脱离线程在退出时将自行释放占用的系统资源
  * 创建线程时默认值为join

* 线程堆栈
  * ulimit -s查看或修改默认值

* 线程调度参数
  * 只有一个优先级参数

* 线程调度策略
  * FIFO
  * RR
  * OTHER

* 线程间竞争CPU的范围
  * 与系统所有线程一起竞争
  * 仅与同一进程的线程竞争

* POSIX信号量
  * pthread_join是一种简单的线程同步方式
  * sem_init
  * sem_destroy
  * sem_wait
  * sem_trywait
  * sem_post


* 互斥锁(pthread_mutex_t)：用于同步线程对共享数据的访问
  * pthread_mutex_init 
    * 也可以使用pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER，该宏将互斥锁的各个字段初始化为0
  * pthread_mutex_destroy
  * pthread_mutex_lock
  * pthread_mutex_trylock：立即返回
  * pthread_mutex_unlock：解锁互斥锁，如果有其他线程正在等待，其中的某一个将获得它
  * 属性
    * pshared：是否可以被跨进程共享
    * type：类型，普通锁、检错锁、嵌套锁、默认锁

* 死锁
  * 使用互斥锁带来的一个问题是死锁，使得一个或多个线程被挂起而无法继续执行，并且不容易被发现
  * case
    * 对一个已经加锁的普通锁再次枷锁，导致死锁
    * 两个线程按照不同顺序申请两个互斥锁，也容易产生死锁


* 条件变量(pthread_cond_t)：在线程之间同步共享数据的值
  * pthread_cond_init: pthread_cond_t cond = PTHREAD_COND_INITIALIZER
  * pthread_cond_destroy：销毁条件变量，释放占用的内核资源，销毁一个正在被等待的条件变量将失败并返回EBUSY
  * pthread_cond_broadcast：以广播方式唤醒所有等待目标统计变量的线程
  * pthread_cond_signal：唤醒一个等待目标条件变量的线程，依赖于线程的优先级和调度策略
    * 如果想唤醒一个指定的线程，没有直接的办法，可以使用间接的方法：定义一个能够唯一标识目标线程的全局变量
  * pthread_cond_wait(pthread_cond_t*, pthread_mutex_t*)：等待目标条件变量
    * mutex是用于保护条件变量的互斥锁，以确保pthread_cond_wait的原子性，在调用前，必须确保互斥锁已经加锁
    * 执行过程
      * 把调用线程放入条件变量的等待队列中，将互斥锁解锁
      * 

* 可重入函数，即线程安全
  * Linux库函数只有一小部分是不可重入的，比如inet_ntoa


* 线程与进程
  * 某个线程调用了fork函数，子进程只拥有一个执行线程，它是调用fork的那个线程的完整复制，并且子进程将自动继承父进程中互斥锁的状态
  * 父进程中已经被加锁的互斥锁在子进程中也是被锁住的


## 进程池
* 由服务器预先创建一组子进程，线程池的线程数量应该和CPU个数差不多，可以完全利用多核
* 所有子进程运行相同代码，具有相同的属性
* 当有新的任务到来时，主进程通过某种方式选择进程池汇总的某一个子进程来为之服务
  * 使用某种算法来主动选择子进程，最简单、最常用的算法是随机算法和Round Robin算法，更优秀、更智能的算法将使任务在各个工作进程中更均匀地分配
  * 主进程和所有子进程通过一个共享的工作队列来同步，子进程都睡眠在工作队列上，当有新任务到来时，主进程将任务添加到工作队列中，这将唤醒正在等待任务的子进程
    不过只有一个子进程将获得新任务的接管权
  * 当选择好子进程后，子进程还需要使用某种通知机制来告诉子进程有新任务需要处理，并传递必要的数据，最简单的方法：在父子进程之间预先建立一条管道。在父子线程之间传递数据简单的多，定义为全局变量，本身是被线程共享的 




