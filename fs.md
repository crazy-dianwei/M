## 文件IO
- 缓冲与非缓冲IO
- 直接与非直接IO
- 阻塞与非阻塞IO VS 同步与非同步IO

### 缓冲与非缓冲IO
#### 缓冲IO
- 利用标准库的缓存失效文件的加速访问，标准库再通过系统调用访问文件

#### 非缓冲IO
- 直接通过系统调用访问文件，不经过标准库缓存

缓冲是指标准库内部实现的缓冲


### 直接与非直接IO
- 内核为了减少磁盘IO次数，在系统调用后，把用户数据拷贝到内核中缓存起来，缓存空间是页缓存
- 根据是否利用操作系统的缓存，把文件IO分为直接IO与非直接IO


### 阻塞IO与非阻塞IO VS 同步IO与异步IO

- 阻塞IO
    * 执行调用，线程被阻塞
    * 阻塞等待的是 ***内核数据准备好*** 和 ***数据从内核态拷贝到用户态***

- 非阻塞IO
    * 在数据未准备好的情况下立即返回，继续往下执行
    * 程序不断轮训内核，直到数据准备好，内核将数据拷贝到应用程序缓冲区
    * 最后一个read调用获取时间的过程是同步的过程，需要等待

- 无论阻塞IO、非阻塞IO，还是基于非阻塞IO的多路复用都是同步调用，因为在read调用时，内核将数据从内核空间拷贝到程序空间，过程都是需要等待的

- 异步IO
    * ***内核数据准备好*** 和 ***数据从内核态拷贝到用户态*** 都不用等待
    * 发起aio_read，立即返回
    * 内核自动将数据从内核空间拷贝到程序空间
    * 与同步不一样，程序不需要主动发起拷贝动作
    * 以通知的形式告诉程序

```sh
            - 阻塞IO 
          /
同步IO -  - - 非阻塞IO
          \
            - 基于非阻塞IO的多路复用

异步IO - - - 异步IO（aio_read）
```

- IO分为两个过程：1. 数据准备过程 2. 数据从内核空间拷贝到用户进程缓冲区的过程
- 阻塞IO会阻塞在 **过程1** 和 **过程2**，而非阻塞IO和基于非阻塞IO的多路复用只会阻塞在 **过程2**，所以这三个都可以认为是同步IO
- 异步IO，**过程1** 和 **过程2** 都不会阻塞















